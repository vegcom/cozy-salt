"""Common enrollment functions shared across all distros."""

from __future__ import annotations

import os
import platform
import subprocess
import sys
import tempfile
import urllib.request
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
  from typing import Sequence

# Bootstrap script URL (vegcom fork with Arch/Python 3.13+ fixes)
BOOTSTRAP_URL = "https://raw.githubusercontent.com/vegcom/salt-bootstrap/refs/heads/develop/bootstrap-salt.sh"
BOOTSTRAP_PS1_URL = "https://raw.githubusercontent.com/vegcom/salt-bootstrap/refs/heads/develop/bootstrap-salt.ps1"


def detect_os() -> tuple[str, str, str]:
  """Detect OS family, distro ID, and version.

  Returns:
      Tuple of (os_family, distro_id, version)
      os_family: 'Linux', 'Windows', 'Darwin'
      distro_id: 'arch', 'debian', 'ubuntu', 'rhel', 'fedora', 'windows', etc.
      version: version string or empty
  """
  system = platform.system()

  if system == "Windows":
    return ("Windows", "windows", platform.version())

  if system == "Darwin":
    return ("Darwin", "macos", platform.mac_ver()[0])

  # Linux - read /etc/os-release
  if system == "Linux":
    os_release = {}
    os_release_path = Path("/etc/os-release")
    if os_release_path.exists():
      for line in os_release_path.read_text().splitlines():
        if "=" in line:
          key, _, value = line.partition("=")
          os_release[key] = value.strip('"')

    distro_id = os_release.get("ID", "unknown").lower()
    version = os_release.get("VERSION_ID", "")

    # Map to families
    debian_family = {"debian", "ubuntu", "kali", "mint", "pop"}
    rhel_family = {"rhel", "centos", "rocky", "almalinux", "fedora", "oracle"}
    arch_family = {"arch", "manjaro", "endeavouros", "steamos"}

    if distro_id in debian_family:
      return ("Debian", distro_id, version)
    elif distro_id in rhel_family:
      return ("RedHat", distro_id, version)
    elif distro_id in arch_family:
      return ("Arch", distro_id, version)
    else:
      return ("Linux", distro_id, version)

  return ("Unknown", "unknown", "")


def download_file(url: str, dest: Path) -> None:
  """Download a file from URL to destination."""
  print(f"Downloading {url}...")
  urllib.request.urlretrieve(url, dest)


def run_command(
  cmd: Sequence[str],
  *,
  check: bool = True,
  capture_output: bool = False,
  env: dict | None = None,
) -> subprocess.CompletedProcess:
  """Run a command with proper error handling."""
  print(f"Running: {' '.join(cmd)}")
  merged_env = {**os.environ, **(env or {})}
  return subprocess.run(
    cmd,
    check=check,
    capture_output=capture_output,
    text=True,
    env=merged_env,
  )


def generate_minion_config(
  master: str,
  minion_id: str,
  roles: list[str],
  environment: str = "development",
) -> str:
  """Generate minion configuration YAML."""
  roles_yaml = "\n".join(f"    - {role}" for role in roles)

  return f"""\
# Salt Minion Configuration
# Generated by install-minion.py

master: {master}
id: {minion_id}

# Grains (custom facts about this minion)
grains:
  roles:
{roles_yaml}
  environment: {environment}

# File client settings
file_client: remote

# Logging
log_level: info
"""


def write_minion_config(
  config_dir: Path,
  master: str,
  minion_id: str,
  roles: list[str],
) -> None:
  """Write minion configuration to disk."""
  config_d = config_dir / "minion.d"
  config_d.mkdir(parents=True, exist_ok=True)

  config_file = config_d / "99-custom.conf"
  config_content = generate_minion_config(master, minion_id, roles)

  print(f"Writing config to {config_file}")
  config_file.write_text(config_content)


def download_bootstrap_script() -> Path:
  """Download the salt-bootstrap script to a temp file."""
  if platform.system() == "Windows":
    suffix = ".ps1"
    url = BOOTSTRAP_PS1_URL
  else:
    suffix = ".sh"
    url = BOOTSTRAP_URL

  fd, path = tempfile.mkstemp(suffix=suffix)
  os.close(fd)
  dest = Path(path)
  download_file(url, dest)
  return dest


def check_root() -> None:
  """Ensure script is running with root/admin privileges."""
  if platform.system() == "Windows":
    import ctypes

    if not ctypes.windll.shell32.IsUserAnAdmin():
      print("Error: This script requires Administrator privileges.")
      sys.exit(1)
  else:
    if os.geteuid() != 0:
      print("Error: This script must be run as root (use sudo)")
      sys.exit(1)


def is_salt_installed() -> bool:
  """Check if salt-minion is already installed."""
  if platform.system() == "Windows":
    return Path(r"C:\salt\salt-minion.exe").exists()
  else:
    result = subprocess.run(
      ["which", "salt-minion"],
      capture_output=True,
    )
    return result.returncode == 0
